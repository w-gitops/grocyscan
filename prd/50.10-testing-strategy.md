# 50.10 Testing Strategy

## 50.10.1 Test Structure

```
tests/
├── conftest.py                    # Shared fixtures
├── phase1/                        # Foundation tests
│   ├── test_database.py
│   ├── test_auth.py
│   └── test_api.py
├── phase2/                        # Inventory tests
│   ├── test_products.py
│   ├── test_locations.py
│   ├── test_stock.py
│   └── test_lookup.py
├── phase3/                        # Device & UI tests
│   ├── test_devices.py
│   └── test_device_api.py
├── phase4/                        # Labels & QR tests
│   ├── test_qr_tokens.py
│   ├── test_qr_routing.py
│   ├── test_labels.py
│   └── test_instances.py
├── phase5/                        # Recipes tests
│   ├── test_recipes.py
│   ├── test_meal_plans.py
│   └── test_shopping_lists.py
├── phase6/                        # Intelligence tests
│   ├── test_people.py
│   ├── test_consumption.py
│   └── test_cost_tracking.py
├── phase7/                        # Documents tests
│   ├── test_paperless.py
│   ├── test_returns.py
│   └── test_grocy_compat.py
├── unit/
│   ├── test_barcode_validator.py
│   ├── test_qr_generator.py
│   └── test_fuzzy_matching.py
└── integration/
    ├── test_scan_flow.py
    └── test_api_endpoints.py
```

## 50.10.2 Test Fixtures

```python
# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
from uuid import uuid4

from app.main import app
from app.database import Base, get_db


TEST_DATABASE_URL = "postgresql://homebot_test:test@localhost:5432/homebot_test"


@pytest.fixture(scope="session")
def engine():
    """Create test database engine."""
    engine = create_engine(TEST_DATABASE_URL)
    Base.metadata.create_all(bind=engine)
    yield engine
    Base.metadata.drop_all(bind=engine)


@pytest.fixture(scope="function")
def db_session(engine):
    """Create a fresh database session for each test."""
    TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    connection = engine.connect()
    transaction = connection.begin()
    session = TestingSessionLocal(bind=connection)
    
    # Set test tenant context
    test_tenant_id = uuid4()
    session.execute(text(f"SET app.tenant_id = '{test_tenant_id}'"))
    
    yield session
    
    session.close()
    transaction.rollback()
    connection.close()


@pytest.fixture(scope="function")
def client(db_session):
    """Create test client with database override."""
    def override_get_db():
        yield db_session
    
    app.dependency_overrides[get_db] = override_get_db
    
    with TestClient(app) as test_client:
        yield test_client
    
    app.dependency_overrides.clear()


@pytest.fixture
def test_tenant(db_session):
    """Create a test tenant."""
    from app.models.tenant import Tenant
    tenant = Tenant(name="Test Household", slug="test")
    db_session.add(tenant)
    db_session.commit()
    return tenant


@pytest.fixture
def test_user(db_session, test_tenant):
    """Create a test user."""
    from app.models.user import User
    user = User(
        email="test@example.com",
        password_hash="hashed",
        default_tenant_id=test_tenant.id
    )
    db_session.add(user)
    db_session.commit()
    return user


@pytest.fixture
def auth_headers(test_user):
    """Create auth headers for API calls."""
    from app.services.auth import create_access_token
    token = create_access_token(user_id=str(test_user.id))
    return {"Authorization": f"Bearer {token}"}
```

## 50.10.3 Phase Test Commands

Each Ralph phase has a standard test command:

```bash
# Phase 1: Foundation
pytest tests/phase1/ -v --tb=short

# Phase 2: Inventory
pytest tests/phase2/ -v --tb=short

# Phase 3: Device & UI (includes BrowserMCP)
npm run test && pytest tests/phase3/ -v

# Phase 4: Labels & QR
pytest tests/phase4/ -v --tb=short

# Phase 5: Recipes
pytest tests/phase5/ -v --tb=short

# Phase 6: Intelligence
pytest tests/phase6/ -v --tb=short

# Phase 7: Documents
pytest tests/phase7/ -v --tb=short

# All tests
pytest tests/ -v --tb=short
```

## 50.10.4 BrowserMCP E2E Testing

For UI criteria, use BrowserMCP via the `cursor-browser-extension` MCP server.

### Workflow

```markdown
1. browser_navigate → Open target URL
2. browser_snapshot → Get page structure with refs (@e1, @e2)
3. [interactions] → click, type, fill using refs
4. browser_take_screenshot → Capture evidence
```

### Example BrowserMCP Validation

```python
# Validate via MCP tool calls during Ralph session

# 1. Navigate (current: NiceGUI on 3334; target: Vue on 3335)
browser_navigate(url="http://localhost:3334")

# 2. Get snapshot for element refs
browser_snapshot()

# 3. Click login button (ref from snapshot)
browser_click(ref="@e5")

# 4. Fill form
browser_fill(ref="@e7", value="test@example.com")
browser_fill(ref="@e8", value="password123")

# 5. Submit
browser_click(ref="@e10")

# 6. Screenshot for evidence
browser_take_screenshot(path=".ralph/screenshots/login-success.png")
```

### BrowserMCP Checklist per Phase

**Phase 3: Device & UI**
```markdown
1. [ ] App loads at localhost:3334 (NiceGUI) or localhost:3335 (Vue target)
2. [ ] Login form accepts credentials
3. [ ] Device registration modal appears
4. [ ] Scan button activates camera
5. [ ] Action mode dropdown works
```

**Phase 4: Labels & QR**
```markdown
1. [ ] Scan unassigned QR, assignment UI appears
2. [ ] Assign QR to product, confirmation shown
3. [ ] Open label designer, template editor works
4. [ ] Preview label, PNG displays
```

## 50.10.5 Unit Test Examples

### QR Token Generator

```python
# tests/unit/test_qr_generator.py
import pytest
from app.services.qr.generator import QRTokenGenerator


class TestQRTokenGenerator:
    def test_generate_code_format(self):
        gen = QRTokenGenerator(namespace="K3D")
        token = gen.generate()
        
        # Format: NS-CODE-CHECK
        assert len(token) == 11  # K3D-XXXXX-X
        assert token[3] == "-"
        assert token[9] == "-"
    
    def test_checksum_validates(self):
        gen = QRTokenGenerator(namespace="K3D")
        token = gen.generate()
        
        assert gen.validate(token) == True
    
    def test_invalid_checksum_fails(self):
        gen = QRTokenGenerator(namespace="K3D")
        
        assert gen.validate("K3D-AAAAA-X") == False  # Wrong checksum
    
    def test_crockford_alphabet(self):
        gen = QRTokenGenerator(namespace="K3D")
        token = gen.generate()
        
        # No I, L, O, U in Crockford Base32
        for char in token.replace("-", ""):
            assert char not in "ILOU"
```

### Location Closure Table

```python
# tests/unit/test_location_hierarchy.py
import pytest
from app.services.location import LocationService


class TestLocationHierarchy:
    def test_create_child_updates_closure(self, db_session, test_tenant):
        service = LocationService(db_session)
        
        parent = service.create(name="Kitchen", tenant_id=test_tenant.id)
        child = service.create(name="Fridge", parent_id=parent.id, tenant_id=test_tenant.id)
        
        # Check closure table
        descendants = service.get_descendants(parent.id)
        assert child.id in [d.id for d in descendants]
    
    def test_get_ancestors(self, db_session, test_tenant):
        service = LocationService(db_session)
        
        home = service.create(name="Home", tenant_id=test_tenant.id)
        kitchen = service.create(name="Kitchen", parent_id=home.id, tenant_id=test_tenant.id)
        fridge = service.create(name="Fridge", parent_id=kitchen.id, tenant_id=test_tenant.id)
        
        ancestors = service.get_ancestors(fridge.id)
        assert len(ancestors) == 2
        assert home.id in [a.id for a in ancestors]
```

## 50.10.6 Integration Tests

```python
# tests/integration/test_scan_flow.py
import pytest


class TestScanFlow:
    def test_scan_known_barcode_adds_stock(self, client, auth_headers, test_tenant):
        # First, create a product
        product_response = client.post(
            "/api/v2/products",
            json={"name": "Test Product", "barcode": "012345678901"},
            headers=auth_headers
        )
        assert product_response.status_code == 201
        
        # Scan the barcode
        scan_response = client.post(
            "/api/v2/stock/add",
            json={
                "barcode": "012345678901",
                "location_id": None,  # Use default
                "quantity": 1
            },
            headers=auth_headers
        )
        
        assert scan_response.status_code == 200
        data = scan_response.json()
        assert data["quantity"] == 1
    
    def test_qr_routing_unassigned_token(self, client):
        # Generate a token
        token = "K3D-7K3QF-X"  # Unassigned
        
        response = client.get(f"/q/{token}", follow_redirects=False)
        
        # Should redirect to assignment page
        assert response.status_code == 302
        assert "/assign" in response.headers["location"]
```

## 50.10.7 Running Tests

```bash
# Run all tests
pytest

# Run with coverage
pytest --cov=app --cov-report=html

# Run specific phase
pytest tests/phase2/ -v

# Run tests matching pattern
pytest -k "test_qr"

# Run with verbose output
pytest -v --tb=long

# Run async tests only
pytest -m asyncio

# Run with parallel execution
pytest -n auto
```

## 50.10.8 Coverage Requirements

| Area | Minimum Coverage |
|------|------------------|
| API Routes | 90% |
| Services | 85% |
| Models | 80% |
| Utils | 75% |
| **Overall** | **80%** |

## 50.10.9 PWA & Device Testing

### Lighthouse PWA Audit

Before each release, run **Lighthouse PWA audit** to verify installability and offline support.

**Required checks (no critical failures):**

| Check | Requirement |
|-------|-------------|
| **Installable** | Valid manifest, service worker, HTTPS | 
| **PWA Optimized** | Redirects HTTP to HTTPS, content sized for viewport |
| **Performance** | LCP ≤2.5s, INP ≤200ms, CLS ≤0.1 (Core Web Vitals "Good") |

**How to run:**

```bash
# In Chrome DevTools
1. Open app URL (e.g., https://homebot.example.com)
2. Open DevTools → Lighthouse tab
3. Select "Mobile" and check "Progressive Web App" + "Performance"
4. Click "Analyze page load"

# Or via CLI (requires lighthouse npm package)
lighthouse https://homebot.example.com --output=html --output-path=./lighthouse-report.html
```

**Optional: Lighthouse CI in pipeline**

```yaml
# .github/workflows/lighthouse.yml
- name: Lighthouse CI
  uses: treosh/lighthouse-ci-action@v12
  with:
    urls: |
      https://homebot.example.com/
    budgetPath: ./lighthouse-budget.json
```

### Viewport / Device Matrix

Test UI at these breakpoints (aligned with 30.13.4):

| Breakpoint | Width | Device Example | Key Checks |
|------------|-------|----------------|------------|
| **xs** | 360px | iPhone SE, Android phone | Single column, bottom nav clears home indicator |
| **sm** | 600px | Large phone, small tablet | Two-column where useful |
| **md** | 768px | iPad Mini, tablet | Primary layout, side nav optional |
| **lg** | 1024px | iPad Pro, desktop | Full layout with sidebars |
| **xl** | 1440px | Desktop monitor | Wide layout |

**How to test:**

1. Use Chrome DevTools → Device Toolbar (Ctrl+Shift+M)
2. Select preset devices or enter custom dimensions
3. Verify layout, navigation, and safe area handling at each breakpoint

### Add to Home Screen Testing

Validate PWA behavior when installed (see [30.13.1.3](30.13-ui-specification.md#301313-add-to-home-screen-testing) for full checklist).

**Quick checks:**

| Platform | Test |
|----------|------|
| **iOS** | Share → "Add to Home Screen" → Launch → Confirm standalone mode |
| **Android** | Install prompt or menu → Launch → Confirm standalone mode, back button |

### Offline Testing

Verify offline behavior using DevTools:

```markdown
1. Open DevTools → Application → Service Workers
2. Check "Offline" checkbox
3. Navigate the app:
   - [ ] Shell loads from cache
   - [ ] Cached product list displays
   - [ ] Scan flow shows offline indicator
   - [ ] Mutations queue locally (if implemented)
4. Uncheck "Offline"
5. Verify queued mutations sync
```

**Real device testing:**

1. Install PWA on device
2. Enable airplane mode
3. Launch app and verify offline behavior
4. Disable airplane mode and verify sync

---

## Navigation

- **Previous:** [Security](40.12-security.md)
- **Next:** [Project Standards](50.11-project-standards.md)
- **Back to:** [README](README.md)
